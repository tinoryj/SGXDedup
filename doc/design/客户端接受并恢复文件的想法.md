## 客户端接受并恢复文件的想法

* 原来的工作流程

  * 以下为我对原本实现方式的理解

    忽略客户端获取file recipe**(fr)**和　key recipe**(kr)**的过程，假设客户端已经取得　file recipe　和 key recip

    * retriver 持有 fr, 经 mq从decoder读取chunk　填到对应位置恢复文件

      > 因为没有数据通路是的retriver告诉server应该传输哪些chunk，server只能在传送完 fr 和 kr 后紧接着根据fr 传输chunk. 但我认为同一个文件中同样会有重复的部分,如果服务器不做辨别直接传输所有的块将会浪费带宽. 若再次去重显然浪费server算力
      >
      > 同时,因为有多个线程同时从mq中取得chunk 进行解密, 则decoder通过mq传送到 retriver中的chunk不按 fr中的顺序, 所以此处在Retriver 再次存在将mq中接收到的chunk根据hash对应到相应位置, 所以应需要一个类似 map 结构存在查找开销

    * decoder 持有kr, 开启多个线程经mq 从 receiver 读取chunk解密后通过mq 传送给 retriver

      > 同理,由于多线程的存在, 从mq 中读取的chunk 同样是无序的,再次需要通过hash到kr 中查找密钥, 因此再次需要一个类似map 的结构和查找开销

    * receiver 无需考虑其它内容, 只负责从网络接受数据并放入mq中

      > receiver除了接受chunk之外, 还需要接受fr 和kr, 其数据只有一条出路, 就是mq. 所以需要在decoder进行辨别提取kr和chunk, 并将fr 继续传入mq中交由retriver, retriver有需要辨别fr 和 chunk, 增加了retriver 和 decoder 的实现复杂度和判断开销

  * 问题总结

    * 单一的mq数据通路使数据交换灵活性降低
    * 多线程接受数据的乱序性导致分别在retriver和decoder都分别引入了一次根据hash 查找的过程
    * 重复的chunk在网络上传输浪费带宽

* 我的想法: 

  * Receiver只需要实现 recvRecipe(recipe name), recvChunkList(), recvData(data)

    recvData为底层调用,负责接受网络数据. 并在此处对socket进行加锁, 保证一写一读, 使得一个request对应一个respond(和 sender实现一样)

    recvRecipe为顶层调用, 调用recvData 获取recipe

    recvChunkList 为一线程, 经mq从decoder 获取requiredChunk, 调用recvData 获取chunk,并压入给decoder的mq中

  * decoder 调用receiver.recvRecipe获取kr, 维护一个缓存，缓存中是hash对应解密后的 chunk

    实现以下方法：

    ​	registerChunk(chunkHash)	由 retriver根据fr 来给缓存中的对应 chunk引用加一

    ​	requestChunk(chunkHash,chunk)	由 retriver根据fr 来给缓存中对应chunk引用减一并返回 chunk

    ​	decryptChunk()为多线程, 经mq从 receiver 获取 chunk 解密并加入缓存中

    ​	缓存:

    ​	缓存通过维护引用次数决定特定chunk的存活时间, 比如一个fr1中chunka 存在3次, fr2 中chunka存在2次, 则引用数为5. retriver 每次调用 registerchunk(chunkHash)则将引用数加一, 每次调用requestChunk则引用数减一, 初次调用registerChunk则通过mq告诉receiver 需要从server 获取该chunk

    

  * retriver 调用 receiver.recvRecipe 获取fr, 按顺序调用requestChunk获取chunk并组装

  * 总结

    * 通过decoder中维护的缓存解决了不在网络上传输相同chunk的问题, 并把计算负担转移到了client
    * 不用区分 MQ 中传输的数据类型, 减少实现复杂度
    * 所有的hash对应chunk的查询操作集中与decoder中的缓存, 是否效率更高不好说,但若是将来优化缓存查找将只需要修改此处, 而不必分别修改decoder和receiver中的 hash-chunk 查找过程, 实现复杂度也减小些. 同时与server 接受recipe 后加定时器处 缓存实现完全相同(或本质相同)
    * 缺点在于引入了三个模块之间的耦合, 若将三个模块视为独立部分, 在以后的版本演化中需要替换可能不太好弄

